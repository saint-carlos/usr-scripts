#!/bin/bash

PROGRAM=`basename $0`
DESCRIPTION="create a patchset to send"
PARAMS="from-rev to-rev [remote-name]"
OPTIONS="[-he] [-p prefix] [-v version] [-s subject] [-o out-dir]"

usage()
{
	[ $1 -ne 0 ] && exec >&2

	cat << EOF
$PROGRAM - $DESCRIPTION
usage:
$PROGRAM $OPTIONS $PARAMS
create a patchset ready to be sent. if remote-name is supplied, it is used to
generate a pull request in the cover letter.

options:
-h	help: show this help message and exit.
-e	edit: edit all patches manually
-p	prefix: set the patchset prefix (e.g. RTK for [RTK PATCH])
-v	version: patchset version
-s	subject: cover letter subject
-o	output: where to put the output

the cover letter and, if -e is given, all other patches, will be edited using
the default editor, which is defined similar to less(1): if the VISUAL
environment variable is defined, it will be used. otherwise, if the EDITOR
environment variable is defined, it will be used. otherwise, if vim(1) is in
the path, it will be used. otherwise, vi(1) will be used.

if out-dir is not given, the output directory will be named based on to-rev
using git-rev-parse(1). if that doesn't work, the output directory will be
named based on to-rev without using git-rev-parse.

exit status:
0:	success
253:	out directory exists
254:	bad arguments
otherwise, exit status from git-format-patch
EOF
	exit $1
}

PREFIX=""
VERSION=""
SUBJECT=""
OUTDIR=""
EDIT=false
while getopts hp:v:s:o:e option; do
	case $option in
		h) usage 0 ;;
		p) PREFIX="$OPTARG " ;;
		v) VERSION=" v$OPTARG" ;;
		s) SUBJECT="$OPTARG" ;;
		o) OUTDIR="$OPTARG" ;;
		e) EDIT=true ;;
		\?) usage 254 ;;
	esac
done
shift $(($OPTIND - 1))
FROM_REV="$1"
TO_REV="$2"
REMOTE="$3"

: ${VISUAL:=$EDITOR}
[ -z "$VISUAL" ] && cmd_exists vim && VISUAL=vim
: ${VISUAL:=vi}

VISUAL_FLAGS=()
[[ $VISUAL =~ ^vi ]] && VISUAL_FLAGS+=("-c" "set textwidth=80")

if [ -z "$OUTDIR" ]; then
	BASENAME=$(basename $TO_REV)
	OUTDIR=$(git rev-parse --abbrev-ref $BASENAME)
	[ -z "$OUTDIR" ] && OUTDIR=$BASENAME
fi


if [ -d "$OUTDIR" ] && [ -n "$(ls -A "$OUTDIR")" ]; then
	echo "$PROGRAM: cannot write to $OUTDIR: Directory not empty"
	exit 253
fi

if [ -n "$REMOTE" ]; then
	REMOTE_URL=$(git remote show -n $REMOTE | grep 'Fetch URL' | awk '{ print $NF }')
	PULL_REQ=$(git request-pull $FROM_REV $REMOTE_URL $TO_REV | head -11)
	if ! grep -q "for you to fetch changes up to" <<< "$PULL_REQ" ; then
		PULL_REQ=$(head -7 <<< "$PULL_REQ")
	fi
else
	PULL_REQ=""
fi

git format-patch -U15 --cover-letter -o "$OUTDIR" --subject-prefix="${PREFIX}PATCH${VERSION}" "${FROM_REV}..${TO_REV}" || exit $?

COVER_LETTER=$OUTDIR/0000-cover-letter.patch
PATCHES=$(ls $OUTDIR/* | grep -vx $COVER_LETTER)
PATCHSET_ID="$(date +%Y%m%d%H%M%S)${VERSION:1}T"

sed -i "s|\*\*\* SUBJECT HERE \*\*\*|$SUBJECT|" $COVER_LETTER
perl -i.bak -pe "s|\*\*\* BLURB HERE \*\*\*|$PULL_REQ|" $COVER_LETTER
sed -i -e '/Subject:/{n;i\' -e "\nID: $PATCHSET_ID" -e ':a;n;ba;}' $COVER_LETTER
sed -i -e '/---/{n;i\' -e "\nPatchset: ${PATCHSET_ID} ${SUBJECT}\n" -e ':a;n;ba;}' $PATCHES
rm ${COVER_LETTER}.bak

if $EDIT; then
	FILES=$OUTDIR/*
else
	FILES=$COVER_LETTER
fi

$VISUAL "${VISUAL_FLAGS[@]}" $FILES

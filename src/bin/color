#!/bin/bash

# AUTHOR:	(c) idank
# VERSION:	1.0
# LICENSE:	GPL (http://www.gnu.org/licenses/gpl.html)
# REQUIRES: none
# NAME:		color
# DESCRIPTION: output stdin to stdout, in color

PROGRAM=`basename $0`
DESCRIPTION="output stdin to stdout, in color."
PARAMS="color"
OPTIONS="[-h]"

usage()
{
	[ $1 -ne 0 ] && exec >&2

	cat << EOF
$PROGRAM - $DESCRIPTION
usage:
$PROGRAM $OPTIONS $PARAMS
printing is line-buffered.

options:
-h	help: show this help message and exit.

exit status:
255	bad arguments
otherwise it is the same as the given command.
EOF

	exit $1
}

while getopts h option; do
	case $option in
		h) usage 0 ;;
		\?) usage 255 ;;
	esac
done
shift `expr $OPTIND - 1`

if [ $# -ne 1 ]; then
	usage 255
fi

# the simplistic implementation would be
# color_seq <color>; cat; color_seq normal
# however, we only want to colorize one stream - our stdout. other streams may
# be intermingled and multiplexed to the terminal. nothing sophisticated is
# implemented at the moment, but a good approximation is that every line
# belongs to one stream, so we color our output line-by-line.
while read LINE; do
	color_echo "$1" "$LINE" 
done

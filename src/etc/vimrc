set runtimepath^=LIB_PLACEHOLDER/vim

" general
" =======

set nocompatible        " Disable vi compatibility.
set nobackup            " Do not keep a backup file.
set iskeyword=@,48-57,_
set noerrorbells        " No beeps.
set magic               " Use 'magic' patterns (extended regular expressions).

" tell vim to find ctags even if in a subdirectory.
set tags=./tags,tags,../tags,../../tags,../../../tags,../../../../tags,../../../../../tags,../../../../../../tag,../../../../../../../tags,../../../../../../../../tag

" view
" ====

set showcmd             " Show (partial) command in status line.
set cmdheight=2		" height of the command line
set number		" show line numbers
set showmode            " Show current mode.
set ruler               " Show the line and column numbers of the cursor.
set modeline            " Enable modeline. BE CAREFUL WITH THAT!!!
set background=dark	" bright terminal colors
set wildmenu		" display file list when browsing files to open
set wildmode=list:longest " bash-like file completion
set laststatus=2	" When to show a statusline.

" buffer view
" ===========

set tabstop=8		" tab width
set linebreak		" wrap on words, not characters
set showmatch           " Show matching brackets.
set listchars=tab:>-,trail:.,extends:> " how to display whitespace when asked
set whichwrap=b,s,<,>,[,] " keys which can move the cursor to another line

if has("syntax")
	syntax on
endif

" syntax highlight shell scripts as per POSIX, not the original Bourne shell which very few use
let g:is_posix = 1

" search & highlight
" ==================

set ignorecase          " Case insensitive matching.
set smartcase		" If search contains capitals, search exact case.
set incsearch           " Incremental search.
set hlsearch            " Highlight search matches.

highlight Normal guifg=White guibg=Black

set autoindent
set smartindent
set shiftwidth=8

set history=100         " Number of lines of command line history.
set undolevels=200      " Number of undo levels.
set textwidth=0         " Don't wrap words by default. set to, for example, 70 to wrap after 70 characters.
set gdefault            " Use 'g' flag by default with :s/foo/bar/.
" set expandtab			" expand tabs to spaces upon typing
" set autochdir			" Automatically cd to file's directory.
" set encoding=utf-8	" Set default encoding to UTF-8.
" set showbreak=+		" Show a '+' if a line is longer than the screen.
" set autowrite			" Automatically save before :next, :make etc.
" set autoread			" auto read when a file is changed from the outside.
" set smarttab			" treat groups of spaces as tabs.

autocmd! bufwritepost vimrc source ~/.vimrc " reload .vimrc if edited
autocmd! bufwritepost vimrc source ETC_PLACEHOLDER/vimrc " reload vimrc if edited

" flag problematic whitespace (trailing and spaces before tabs). Note you get the same by doing let c_space_errors=1 but this rule really applys to everything.
hi RedundantSpaces term=standout ctermbg=red guibg=red
" match RedundantSpaces /\s\+$\| \+\ze\t/	"\ze sets end of match so only spaces highlighted
" use :set list! to toggle visible whitespace on/off

set backspace=indent,eol,start			" Allow backspacing over everything in insert mode.

" Enable this if you mistype :w as :W or :q as :Q.
" nmap :W :w
" nmap :Q :q

" Correct typos.
iab beacuse    because
iab becuase    because
iab acn        can
iab cna        can
iab centre     center
iab chnage     change
iab chnages    changes
iab chnaged    changed
iab chnagelog  changelog
iab Chnage     Change
iab Chnages    Changes
iab ChnageLog  ChangeLog
iab debain     debian
iab Debain     Debian
iab defualt    default
iab Defualt    Default
iab differnt   different
iab diffrent   different
iab emial      email
iab Emial      Email
iab figth      fight
iab figther    fighter
iab fro        for
iab fucntion   function
iab ahve       have
iab homepgae   homepage
iab logifle    logfile
iab lokk       look
iab lokking    looking
iab mial       mail
iab Mial       Mail
iab miantainer maintainer
iab amke       make
iab mroe       more
iab nwe        new
iab recieve    receive
iab recieved   received
iab erturn     return
iab retrun     return
iab retunr     return
iab seperate   separate
iab shoudl     should
iab soem       some
iab taht       that
iab thta       that
iab teh        the
iab tehy       they
iab truely     truly
iab waht       what
iab wiht       with
iab whic       which
iab whihc      which
iab yuo        you
iab databse    database
iab versnio    version
iab obnsolete  obsolete
iab flase      false
iab recrusive  recursive
iab Recrusive  Recursive


filetype plugin indent on
au FileType make setlocal noexpandtab  "'tab' means 'tab' in makefiles

" F5: left to right
" F6: right to left.
map <F5> %s/\s\+$//
map  <F5> <esc>:set guifont=FreeSans<cr>:set norightleft<cr>:set nohk<cr>i
map! <F5> <esc>:set guifont=FreeSans<cr><esc>:set norightleft<cr>:set nohk<cr>a
map  <F6> <esc>:set guifont=-Hebrew-Bible-Medium-R-Normal--16-160-75-75-M-80-ISO8859-8<cr><esc>:set rightleft<cr>:set hk<cr>i
map! <F6> <esc>:set guifont=-Hebrew-Bible-Medium-R-Normal--16-160-75-75-M-80-ISO8859-8<cr><esc>:set rightleft<cr>:set hk<cr>a
map! <F8> <esc>:w<cr>i
map  <F8> :w<cr>

map <leader>cd :cd %:p:h<cr> " When pressing <leader>cd switch to the directory of the open buffer

if has("cscope")
	set cscopetag	" treat scsope tags like ctags
	set csto=0		" boolean: should ctags be queried before cscope?
	set cst
	set nocsverb	" non verbose mode (when adding a database)

	" add any database in current directory
	if filereadable("cscope.out")
		cs add cscope.out
	" else add database pointed to by environment
	elseif $CSCOPE_DB != ""
		cs add $CSCOPE_DB
	endif

	if filereadable("../cscope.out")
		cs add ../cscope.out
	endif
	if filereadable("../../cscope.out")
		cs add ../../cscope.out
	endif
	if filereadable("../../../cscope.out")
		cs add ../../../cscope.out
	endif
	if filereadable("../../../../cscope.out")
		cs add ../../../../cscope.out
	endif
	if filereadable("../../../../../cscope.out")
		cs add ../../../../../cscope.out
	endif
	if filereadable("../../../../../../cscope.out")
		cs add ../../../../../../cscope.out
	endif
	if filereadable("../../../../../../../cscope.out")
		cs add ../../../../../../../cscope.out
	endif
	if filereadable("../../../../../../../../cscope.out")
		cs add ../../../../../../../../cscope.out
	endif

	" CScope related mappings.
	" Original CScope commands (as issued via ':cs find <querytype>'):
	"	0 or s: Find this C symbol
	"	1 or g: Find this definition
	"	2 or d: Find functions called by this function
	"	3 or c: Find functions calling this function
	"	4 or t: Find this text string
	"	6 or e: Find this egrep pattern
	"	7 or f: Find this file
	"	8 or i: Find files #including this file

	" map \cX to :cs find X
	nmap <Leader>cs :cs find s <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>c0 :cs find s <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>cg :cs find g <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>c1 :cs find g <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>cd :cs find d <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>c2 :cs find d <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>cc :cs find c <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>c3 :cs find c <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>ct :cs find t <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>c4 :cs find t <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>ce :cs find e <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>c6 :cs find e <C-R>=expand("<cword>")<CR><CR>
	nmap <Leader>cf :cs find f <C-R>=expand("<cfile>")<CR><CR>
	nmap <Leader>c7 :cs find f <C-R>=expand("<cfile>")<CR><CR>
	nmap <Leader>ci :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
	nmap <Leader>c8 :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
endif

" For TabBar plugin: make it open not 'at the edge of screen', whatever
" that's supposed to mean (doesn't cure 'showing at the top of leftmost
" vertically split window only' problem, unfortunately) :
" let g:Tb_SplitToEdge = 0

" For TabBar plugin: set up tab bar depending on screen width:
"if &columns <= 125 "screen NOT wide enough for vertical tabbar:
if &columns <= 115 "screen NOT wide enough for vertical tabbar:
    " make tab bar multiline (use as many lines as necessary) and make sure
    " no tab is 'cut' to next line:
    let g:Tb_TabWrap = 1
    let g:Tb_MaxSize = 0
else " screen wide-enough for vertical tabbar:
    " open tab bar side-by-side with main window, on the right:
    let g:Tb_VSplit = 1
    let g:Tb_SplitBelow = 1
    let g:Tb_MinSize = 25
    let g:Tb_MaxSize = 25
endif

" For TabBar plugin : prevent from opening when in diff mode. From help :
"   In your .vimrc file you could do something special when Vim was
"   started in diff mode.  You could use a construct like this:
"     if &diff
"         setup for diff mode
"     else
"         setup for non-diff mode
"     endif
" For this to work, tabbar.vim must be patched with the following IF right
" at the beginning, obviously :
"   if exists("g:V_DirDiffRunning")
"       finish
"   endif
if &diff
    let g:V_DirDiffRunning = 1
endif

" For TabBar plugin: allow single-click tab switching
let g:Tb_UseSingleClick = 1

" FSwitch
let g:fsnonewfiles = 1
map <c-h> :FSHere<cr>

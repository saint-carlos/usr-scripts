#!/bin/bash

# ls
__LS_FLAGS="-Fh"
alias lsd='ls -d'
alias llx='ll -X'
alias lld='ll -d'
alias lla='ll -A'
alias tree='tree -CshF --dirsfirst'

# processes
alias psx='ps -e -o pid,ppid,user,flags,stat,wchan:16,tty,start,cmd -ww | less'
cmd_exists htop && alias top='htop'

# misc
__COREUTILS_FLAGS="-v"
alias du='du -hs'
alias df='df -h'
alias findc='findgrep -c'
if cmd_exists colordiff; then
	alias diff='colordiff -U20'
else
	alias diff='diff -U20'
fi

export LESS='--LONG-PROMPT --RAW-CONTROL-CHARS --ignore-case --window=-4 --jump-target=4 -Pm?c<--%c-- .[ ?f"%f":<PIPE>. | Ln %lt?L of %L. | Pg %db?B of %D.?e | 100\%:?pm | %Pm\%.. ]' # default LESS configuration
export GREP_COLORS="fn=35;1" # grep filename color is brighter

unset MAIL MAILCHECK MAILPATH # don't check mail

# more informative trace when debugging bash scripts
export PS4='+ $$:${BASH_SOURCE##*/}:${BASH_LINENO}:${FUNCNAME}: '

WORKSPACE=CONFIG_WORKSPACE
for REPO_ROOT in "$WORKSPACE" CONFIG_REPO_DIRS; do
	if [ -d "$REPO_ROOT" ]; then
		REPOSITORY_ROOTS="$REPOSITORY_ROOTS $REPO_ROOT"
	fi
done
export REPOSITORY_ROOTS

__BOLD="$(tput smul)"
__UNBOLD="$(tput rmul)"
__PROMPT_ERROR_COLOR="$(__color_seq red)"
if [ -n "${SSH_CLIENT-}" ]; then
	__MAKE_BOLD='\['"$__BOLD"'\]'
	__MAKE_UNBOLD='\['"$__UNBOLD"'\]'
else
	__MAKE_BOLD=""
	__MAKE_UNBOLD=""
fi
__USER=""
if CONFIG_PROMPT_USERNAME; then
	__USER='\u@'
fi

__set_prompt()
{
	__STATUS=$? # must be first line ever of this function

	local PWD_MAXLEN=$((CONFIG_PWD_SCREEN_PERCENT * COLUMNS / 100))

	local GIT_REPO=$(git rev-parse --show-toplevel 2>/dev/null)
	if [ -n "$GIT_REPO" ]; then
		GIT_REPO=$(basename $GIT_REPO)
		local GIT_HEAD=$(__git_ps1 "%s" 2>/dev/null)
		__LOCATION_ROOT="${GIT_REPO}[${GIT_HEAD}]"
		__LOCATION=$(git rev-parse --show-prefix)
		__LOCATION=${__LOCATION%/}
		local TOTAL_LEN=$((${#__LOCATION}  + ${#__LOCATION_ROOT}))
		if [ -n "$__LOCATION" ] && [ $TOTAL_LEN -gt $PWD_MAXLEN ]; then
			local TMP=$(basename $__LOCATION)
			if [ $TMP != $__LOCATION ]; then
				TMP=".../${TMP}"
				if [ ${#TMP} -lt ${#__LOCATION} ]; then
					__LOCATION=${TMP}
				fi
			fi
		fi
		__LOCATION="/${__LOCATION}"
	else
		__LOCATION="${PWD/#$HOME/~}"

		# this will cause pwd to be trimmed on a greater threshold than it
		# should if the beginning is something like "${HOME}1", because we
		# will think its "~1", but for now its the best we can do.
		if [ ${#__LOCATION} -gt $PWD_MAXLEN ]; then
			PROMPT_DIRTRIM=1
			__LOCATION_ROOT=/
		else
			PROMPT_DIRTRIM=0
			__LOCATION_ROOT=""
		fi

		if [[ ${__LOCATION:0:1} = "~" && / =~ ${__LOCATION:1:1} ]]; then
		# a real home, not something like "${HOME}1"
			__LOCATION_ROOT=""
		fi

		__LOCATION="" # let bash sort it out, it's better at it.
	fi

	__PROMPT_ERROR_COLOR_SET=""
	if [ $__STATUS -eq 0 ]; then
		__PROMPT_STATUS_DESC=""
	elif [ $__STATUS -gt 128 ] && [ $__STATUS -lt 192 ]; then # signal
		local SIG=$(kill -l $((__STATUS - 128)))
		__PROMPT_STATUS_DESC=" ($SIG)"
		case $SIG in
			HUP|ILL|ABRT|BUS|FPE|SEGV|STKFLT|SYS)
				__PROMPT_ERROR_COLOR_SET="$__PROMPT_ERROR_COLOR"
				;;
		esac
	else
		__PROMPT_STATUS_DESC=" (${__STATUS})"
		__PROMPT_ERROR_COLOR_SET="$__PROMPT_ERROR_COLOR"
	fi

	__PROMPT_BG_JOBS_SET=""
	__PROMPT_BG_JOBS_RESET=""
	if jobs | grep -q .; then
		__PROMPT_BG_JOBS_SET="$__BOLD"
		__PROMPT_BG_JOBS_RESET="$__UNBOLD"
	fi

	# my shell ignores the return value of this function rather than
	# put it in $?, but i don't know about other shells
	return $__STATUS
}
PROMPT_COMMAND=__set_prompt
PS1="${__PROMPT_COLOR_SET}\\! \D{%y-%m-%d %T} ${__USER}${__MAKE_BOLD}\h${__MAKE_UNBOLD}:\${__LOCATION_ROOT}\${__LOCATION:-\w}\[\${__PROMPT_ERROR_COLOR_SET}\]\${__PROMPT_STATUS_DESC}${__PROMPT_COLOR_SET}\[\${__PROMPT_BG_JOBS_SET}\]\\\$\[\${__PROMPT_BG_JOBS_RESET}\]${__PROMPT_COLOR_RESET} "

__get_working_copy()
{
	if [ $# -eq 0 ]; then
		return
	fi
	if [ $# -eq 1 ]; then
		for REPO_ROOT in $REPOSITORY_ROOTS; do
			if [ -d "$REPO_ROOT/$1" ]; then
				WORKING_COPY="$REPO_ROOT/$1"
				break
			fi
		done
	fi
	if [ -z "$WORKING_COPY" ]; then
		set $(echo "$@" | sed 's/[1-9][1-9]*/ & /g') # shorthand: a1b -> a 1 b
		REPOS=$(echo "$REPOSITORY_ROOTS " | sed 's|^ *||; s| |/* |g') # append /* to repos
		LIST=$(\ls -u1d $REPOS) # list by access time from most recent
		for ITEM in "$@"; do
			LIST=$(echo "$LIST" | \grep -i /[^/]*$ITEM[^/]*$) # grep the basename
		done
		WORKING_COPY=$(echo "$LIST" | sed 1q)
	fi
	echo "$WORKING_COPY"
}

__jump_working_copy()
{
	cd `__get_working_copy $@`
}

# 'j' jumps around the user's working directoy using short mnemonics
alias j="__jump_working_copy"

#!/bin/bash

# ls
__LS_FLAGS="-Fh"
alias lsd='ls -d'
alias llx='ll -X'
alias lld='ll -d'
alias lla='ll -A'
alias tree='tree -CshF --dirsfirst'

# processes
alias psx='ps -e -o pid,ppid,user,flags,stat,wchan,tty,start,cmd -ww | less'
cmd_exists htop && alias top='htop'
cmd_exists vim && alias vi='vim'

# misc
__COREUTILS_FLAGS="-v"
alias du='du -hs'
alias df='df -h'
alias diff='diff -U20'
alias findc='findgrep -c'

export LESS="-MRi -z-4" # default LESS configuration
export GREP_COLORS="fn=35;1" # grep filename color is brighter

unset MAIL MAILCHECK MAILPATH # don't check mail

# more informative trace when debugging bash scripts
export PS4='+ $$:$(basename ${BASH_SOURCE}):${BASH_LINENO}:${FUNCNAME}: '

WORKSPACE=WORKSPACE_PLACEHOLDER
for REPO_ROOT in "$WORKSPACE" REPO_ROOT_LIST_PLACEHOLDER; do
	if [ -d "$REPO_ROOT" ]; then
		REPOSITORY_ROOTS="$REPOSITORY_ROOTS $REPO_ROOT"
	fi
done
export REPOSITORY_ROOTS

__PROMPT_ERROR_COLOR="$(color_seq red)"
case $TERM in
	xterm*|rxvt*) __TITLEBAR="\[\e]0;\h:\${__LOCATION_ROOT}\${__LOCATION:-\w}\007\]" ;;
	*) __TITLEBAR="" ;;
esac
if [ -n "$SSH_CLIENT" ]; then
	HOSTNAME_BOLD='\['"$(tput smul)"'\]'
	HOSTNAME_UNBOLD='\['"$(tput rmul)"'\]'
else
	HOSTNAME_BOLD=""
	HOSTNAME_UNBOLD=""
fi
if PROMPT_USERNAME_PLACEHOLDER; then
	__USER='\u@'
fi

__set_prompt()
{
	__STATUS=$? # must be first line ever of this function

	local PWD_MAXLEN=$((PWD_PERCENTAGE_PLACEHOLDER * COLUMNS / 100))

	local GIT_REPO=$(git rev-parse --show-toplevel 2>/dev/null)
	if [ -n "$GIT_REPO" ]; then
		GIT_REPO=$(basename $GIT_REPO)
		local GIT_HEAD=$(__git_ps1 "%s" 2>/dev/null)
		__LOCATION_ROOT="${GIT_REPO}[${GIT_HEAD}]"
		__LOCATION=$(git rev-parse --show-prefix)
		__LOCATION=${__LOCATION%/}
		local TOTAL_LEN=$((${#__LOCATION}  + ${#__LOCATION_ROOT}))
		if [ -n "$__LOCATION" ] && [ $TOTAL_LEN -gt $PWD_MAXLEN ]; then
			local TMP=$(basename $__LOCATION)
			if [ $TMP != $__LOCATION ]; then
				TMP=".../${TMP}"
				if [ ${#TMP} -lt ${#__LOCATION} ]; then
					__LOCATION=${TMP}
				fi
			fi
		fi
		__LOCATION="/${__LOCATION}"
	else
		__LOCATION="${PWD/#$HOME/~}"

		# this will cause pwd to be trimmed on a greater threshold than it
		# should if the beginning is something like "${HOME}1", because we
		# will think its "~1", but for now its the best we can do.
		if [ ${#__LOCATION} -gt $PWD_MAXLEN ]; then
			PROMPT_DIRTRIM=1
			__LOCATION_ROOT=/
		else
			PROMPT_DIRTRIM=0
			__LOCATION_ROOT=""
		fi

		if [[ ${__LOCATION:0:1} = "~" && / =~ ${__LOCATION:1:1} ]]; then
		# a real home, not something like "${HOME}1"
			__LOCATION_ROOT=""
		fi

		__LOCATION="" # let bash sort it out, it's better at it.
	fi

	__PROMPT_ERROR_COLOR_SET=""
	if [ $__STATUS -eq 0 ]; then
		__PROMPT_STATUS_DESC=""
	elif [ $__STATUS -gt 128 ] && [ $__STATUS -lt 192 ]; then
		__PROMPT_STATUS_DESC=" ($(kill -l $((__STATUS - 128))))"
	else
		__PROMPT_STATUS_DESC=" (${__STATUS})"
		__PROMPT_ERROR_COLOR_SET="$__PROMPT_ERROR_COLOR"
	fi

	# my shell ignores the return value of this function rather than
	# put it in $?, but i don't know about other shells
	return $__STATUS
}
PROMPT_COMMAND=__set_prompt
PS1="${__TITLEBAR}${__PROMPT_COLOR_SET}\\! \D{%y-%m-%d %T} ${__USER}${HOSTNAME_BOLD}\h${HOSTNAME_UNBOLD}:\${__LOCATION_ROOT}\${__LOCATION:-\w}\[\${__PROMPT_ERROR_COLOR_SET}\]\${__PROMPT_STATUS_DESC}${__PROMPT_COLOR_SET}\\\$${__PROMPT_COLOR_RESET} "

__get_working_copy()
{
	if [ $# -eq 0 ]; then
		return
	fi
	if [ $# -eq 1 ]; then
		for REPO_ROOT in $REPOSITORY_ROOTS; do
			if [ -d "$REPO_ROOT/$1" ]; then
				echo "$REPO_ROOT/$1"
				return
			fi
		done
	fi
	set `echo "$@" | sed 's/[1-9][1-9]*/ & /g'` # shorthand: a1b -> a 1 b
	REPOS=`echo "$REPOSITORY_ROOTS " | sed 's|^ *||; s| |/* |g'` # append /* to repos
	LIST=`\ls -u1d $REPOS` # list by access time from most recent
	for ITEM in "$@"; do
		LIST=`echo "$LIST" | \grep -i /[^/]*$ITEM[^/]*$` # grep the basename
	done
	echo "$LIST" | sed 1q
}

__jump_working_copy()
{
	cd `__get_working_copy $@`
}

# 'j' jumps around the user's working directoy using short mnemonics
alias j="__jump_working_copy"

#!/bin/bash

[[ $- == *i* ]] || return

ETC=ETC_PLACEHOLDER
BIN=BIN_PLACEHOLDER
SBIN=SBIN_PLACEHOLDER

export PATH=$PATH:$BIN
if [ $UID -eq 0 ]; then
	export PATH=$PATH:$SBIN
fi

source $ETC/bash_completion
shopt -s no_empty_cmd_completion
shopt -s hostcomplete

source $ETC/colorsrc

if [ $UID -eq 0 ]; then
	__PROMPT_COLOR_SET="\[$(color_seq ROOT_PROMPT_COLOR_PLACEHOLDER)\]"
else
	__PROMPT_COLOR_SET="\[$(color_seq USER_PROMPT_COLOR_PLACEHOLDER)\]"
fi
__PROMPT_COLOR_RESET="\[$(color_seq normal)\]"
PS1="${__PROMPT_COLOR_SET}\u@\h:\w\\\$${__PROMPT_COLOR_RESET} "

source $ETC/bashrc.user

alias mkdir='mkdir -p'

# careful
alias cp="cp -i $__COREUTILS_FLAGS"
alias rm="rm -i $__COREUTILS_FLAGS"
alias mv="mv -i $__COREUTILS_FLAGS"
alias ln="ln -i $__COREUTILS_FLAGS"

alias ls="ls $__LS_FLAGS"
alias ll="ls -l $__LS_FLAGS"
alias la="ls -A $__LS_FLAGS"

cmd_exists vim && alias vi='vim' && alias view='vim -R'

ulimit -c unlimited

export PAGER=less

export HISTTIMEFORMAT='%F %T '
export HISTCONTROL=ignorespace # don't ignore dups, it might be useful when printing history with timestamps
export HISTSIZE=20000
export HISTFILESIZE=5000
export HISTIGNORE="exit:logout:reboot:shutdown:poweroff:return:clear:history:bg:fg:jobs:pwd:ls:ll:la:cd:ps"

stty -ixon # disable ^S/^Q
test -t 0 && stty -ctlecho

unset ETC BIN SBIN USER_PROMPT_COLOR ROOT_PROMPT_COLOR
true # so that sourcing the file won't return error
